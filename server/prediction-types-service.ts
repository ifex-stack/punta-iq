import { logger } from "./logger";

// Import StandardizedMatch from sports-api-service to ensure consistency
import { StandardizedMatch as BaseStandardizedMatch } from './sports-api-service';

// Use the imported type to maintain consistency across services
export type StandardizedMatch = BaseStandardizedMatch;

/**
 * Types of predictions supported by the platform
 */
export enum PredictionType {
  MATCH_RESULT = "match_result", // 1X2 - Home, Draw, Away
  BTTS = "btts", // Both Teams To Score
  OVER_UNDER = "over_under", // Over/Under goals
  CORRECT_SCORE = "correct_score", // Exact score prediction
  DOUBLE_CHANCE = "double_chance", // Double chance (Home/Draw, Draw/Away, Home/Away)
  HT_FT = "ht_ft", // Half-time/Full-time
  CLEAN_SHEET = "clean_sheet", // Team keeps a clean sheet
  WIN_TO_NIL = "win_to_nil", // Team wins without conceding
  TOTAL_GOALS = "total_goals", // Number of goals in ranges (0-1, 2-3, 4+)
  FIRST_SCORER = "first_scorer", // First player to score
  ANYTIME_SCORER = "anytime_scorer", // Player to score anytime
  CORNER_COUNT = "corner_count", // Total corners
  CARD_COUNT = "card_count", // Total cards
}

/**
 * Types of accumulators generated by the platform
 */
export enum AccumulatorType {
  HOME_WIN_SPECIAL = "home_win_special", // Accumulator of home wins
  VALUE_FINDER = "value_finder", // Accumulator of value bets
  UPSET_SPECIAL = "upset_special", // Accumulator of potential upsets
  GOALS_GALORE = "goals_galore", // Accumulator of BTTS
  GOALS_FIESTA = "goals_fiesta", // Accumulator of over 2.5 goals
  WEEKEND_BANKER = "weekend_banker", // Safest weekend picks
  LONGSHOT_HERO = "longshot_hero", // High-odds selections
  GLOBAL_EXPLORER = "global_explorer", // Picks from different leagues around the world
  DRAW_SPECIALIST = "draw_specialist", // Matches likely to end in draws
  CLEAN_SHEET_KINGS = "clean_sheet_kings", // Teams likely to keep clean sheets
}

/**
 * Risk level for accumulators
 */
export enum RiskLevel {
  SAFE = "safe", // Lower risk, higher probability
  BALANCED = "balanced", // Medium risk, medium reward
  RISKY = "risky", // High risk, high reward
}

export interface PredictionOutcome {
  type: PredictionType;
  prediction: string;
  confidence: number;
  odds?: number;
  explanation: string;
  valueRating?: number; // 1-5 rating of value (if odds available)
  isValueBet?: boolean;
}

export interface PredictionParams {
  match: StandardizedMatch;
  includeValue?: boolean;
}

export interface AccumulatorParams {
  matches: StandardizedMatch[];
  type: AccumulatorType;
  risk: RiskLevel;
  maxSelections?: number;
  minConfidence?: number;
}

export interface AccumulatorSelection {
  matchId: string;
  homeTeam: string;
  awayTeam: string;
  league: string;
  startTime: string;
  predictionType: PredictionType;
  selection: string;
  confidence: number;
  odds: number;
  explanation: string;
}

export interface Accumulator {
  id: string;
  type: AccumulatorType;
  name: string;
  description: string;
  risk: RiskLevel;
  selections: AccumulatorSelection[];
  totalOdds: number;
  potentialReturn: number; // Based on Â£1 stake
  confidence: number;
  createdAt: string;
  sport: string;
  isFeatured?: boolean;
}

/**
 * Service for generating different types of predictions and accumulators
 */
export class PredictionTypesService {
  
  /**
   * Generate all prediction types for a match
   * @param params Prediction parameters
   */
  generateAllPredictions(params: PredictionParams): PredictionOutcome[] {
    const predictions: PredictionOutcome[] = [];
    const { match, includeValue } = params;
    
    try {
      // Match Result (1X2)
      predictions.push(this.generateMatchResultPrediction(match));
      
      // For soccer matches, add soccer-specific predictions
      if (match.sport.includes('soccer') || match.league.toLowerCase().includes('league') || 
          match.league.toLowerCase().includes('serie') || match.league.toLowerCase().includes('bundesliga')) {
        
        predictions.push(this.generateBTTSPrediction(match));
        predictions.push(this.generateOverUnderPrediction(match, 2.5));
        predictions.push(this.generateDoubleChancePrediction(match));
        predictions.push(this.generateCleanSheetPrediction(match));
        predictions.push(this.generateTotalGoalsPrediction(match));
      }
      
      // For basketball matches, add basketball-specific predictions
      if (match.sport.includes('basketball')) {
        predictions.push(this.generateOverUnderPrediction(match, 220.5));
        predictions.push(this.generatePointSpreadPrediction(match));
      }
      
      // Calculate value ratings if requested and odds are available
      if (includeValue) {
        return predictions.map(prediction => {
          if (prediction.odds) {
            const valueRating = this.calculateValueRating(prediction);
            return {
              ...prediction,
              valueRating,
              isValueBet: valueRating >= 4
            };
          }
          return prediction;
        });
      }
      
      return predictions;
    } catch (error: any) {
      logger.error('PredictionTypesService', `Error generating predictions: ${error.message}`);
      // Return at least match result prediction if possible
      if (predictions.length > 0) {
        return predictions;
      }
      
      // Return a basic prediction with explanation of error
      return [{
        type: PredictionType.MATCH_RESULT,
        prediction: match.homeOdds && match.awayOdds ? 
          (match.homeOdds < match.awayOdds ? "Home Win" : "Away Win") : 
          "Home Win",
        confidence: 50,
        explanation: "Basic prediction due to error in generating detailed predictions."
      }];
    }
  }
  
  /**
   * Generate match result (1X2) prediction
   */
  generateMatchResultPrediction(match: StandardizedMatch): PredictionOutcome {
    let prediction = "Home Win";
    let confidence = 65;
    let odds: number | undefined;
    
    // Simple odds-based prediction
    if (match.homeOdds && match.awayOdds) {
      if (match.homeOdds < match.awayOdds) {
        prediction = "Home Win";
        confidence = Math.round(90 - (match.homeOdds * 10));
        odds = match.homeOdds;
      } else {
        prediction = "Away Win";
        confidence = Math.round(90 - (match.awayOdds * 10));
        odds = match.awayOdds;
      }
      
      // If draw odds are lowest (for sports with draws)
      if (match.drawOdds && match.drawOdds < match.homeOdds && match.drawOdds < match.awayOdds) {
        prediction = "Draw";
        confidence = Math.round(80 - (match.drawOdds * 10));
        odds = match.drawOdds;
      }
    }
    
    // Cap confidence between 35-95%
    confidence = Math.min(Math.max(confidence, 35), 95);
    
    // Generate explanation
    const explanation = `Based on odds analysis, ${match.homeTeam} vs ${match.awayTeam} is predicted to result in a ${prediction.toLowerCase()}. ${this.getMatchResultExplanation(prediction, confidence, match)}`;
    
    return {
      type: PredictionType.MATCH_RESULT,
      prediction,
      confidence,
      odds,
      explanation
    };
  }
  
  /**
   * Generate BTTS (Both Teams To Score) prediction
   */
  generateBTTSPrediction(match: StandardizedMatch): PredictionOutcome {
    // Form a prediction based on team form and available information
    const homeStrength = this.getImpliedProbabilityFromOdds(match.homeOdds);
    const awayStrength = this.getImpliedProbabilityFromOdds(match.awayOdds);
    
    // If both teams are relatively strong, more likely for BTTS
    const bttsLikelihood = (homeStrength + awayStrength) / 2;
    
    // Determine prediction and confidence
    let prediction: string;
    let confidence: number;
    
    if (bttsLikelihood > 0.4) {
      prediction = "Yes";
      confidence = Math.round(bttsLikelihood * 100);
    } else {
      prediction = "No";
      confidence = Math.round((1 - bttsLikelihood) * 100);
    }
    
    // Cap confidence between 45-85% for BTTS predictions (more uncertain)
    confidence = Math.min(Math.max(confidence, 45), 85);
    
    // Generate explanation
    const explanation = prediction === "Yes"
      ? `Our analysis suggests both ${match.homeTeam} and ${match.awayTeam} will score in this match. Both teams have shown attacking capability, and the game dynamics favor an open contest.`
      : `Our analysis suggests at least one team will fail to score in this match. Expecting a more defensive game with limited opportunities for both sides.`;
    
    return {
      type: PredictionType.BTTS,
      prediction,
      confidence,
      explanation
    };
  }
  
  /**
   * Generate Over/Under prediction
   */
  generateOverUnderPrediction(match: StandardizedMatch, line: number): PredictionOutcome {
    let prediction: string;
    let confidence: number;
    
    // For soccer, use different logic than basketball
    if (match.sport.includes('soccer') || match.league.toLowerCase().includes('league')) {
      const homeStrength = this.getImpliedProbabilityFromOdds(match.homeOdds);
      const awayStrength = this.getImpliedProbabilityFromOdds(match.awayOdds);
      
      // Higher combined strength suggests more goals
      const totalStrength = homeStrength + awayStrength;
      
      if (totalStrength > 0.8) {
        prediction = "Over";
        confidence = Math.round(totalStrength * 50);
      } else {
        prediction = "Under";
        confidence = Math.round((1 - totalStrength) * 70);
      }
      
      // Adjust confidence based on league tendencies (could be improved with historical data)
      if (match.league.includes("Serie A") || match.league.includes("Ligue")) {
        // Historically lower scoring leagues
        confidence = prediction === "Under" ? confidence + 5 : confidence - 5;
      } else if (match.league.includes("Bundesliga") || match.league.includes("Eredivisie")) {
        // Historically higher scoring leagues
        confidence = prediction === "Over" ? confidence + 5 : confidence - 5;
      }
    } else {
      // Basketball - simplified logic
      prediction = Math.random() > 0.5 ? "Over" : "Under";
      confidence = 55 + Math.floor(Math.random() * 20);
    }
    
    // Cap confidence for over/under bets
    confidence = Math.min(Math.max(confidence, 40), 80);
    
    const lineTerm = match.sport.includes('soccer') ? `${line} goals` : line.toString();
    
    return {
      type: PredictionType.OVER_UNDER,
      prediction,
      confidence,
      explanation: `Based on team form and league averages, we predict ${prediction.toLowerCase()} ${lineTerm} for ${match.homeTeam} vs ${match.awayTeam}. ${prediction === "Over" ? "Expect an open, high-scoring game." : "Expect a tighter, defensive contest."}`
    };
  }
  
  /**
   * Generate Double Chance prediction
   */
  generateDoubleChancePrediction(match: StandardizedMatch): PredictionOutcome {
    let prediction: string;
    let confidence: number;
    
    if (!match.homeOdds || !match.awayOdds) {
      prediction = "Home/Draw";
      confidence = 70;
    } else if (match.homeOdds <= match.awayOdds) {
      prediction = "Home/Draw";
      confidence = Math.round(100 - (match.homeOdds * 15));
    } else {
      prediction = "Away/Draw";
      confidence = Math.round(100 - (match.awayOdds * 15));
    }
    
    // For very close matches, home advantage might still be significant
    if (match.homeOdds && match.awayOdds && Math.abs(match.homeOdds - match.awayOdds) < 0.3) {
      prediction = "Home/Draw";
      confidence = Math.min(confidence, 75);
    }
    
    // Cap confidence for double chance (naturally higher)
    confidence = Math.min(Math.max(confidence, 60), 90);
    
    return {
      type: PredictionType.DOUBLE_CHANCE,
      prediction,
      confidence,
      explanation: `The double chance selection of ${prediction} provides security against the draw. ${prediction.includes("Home") ? match.homeTeam : match.awayTeam} have solid form that supports avoiding defeat in this match.`
    };
  }
  
  /**
   * Generate Clean Sheet prediction
   */
  generateCleanSheetPrediction(match: StandardizedMatch): PredictionOutcome {
    let team: string;
    let prediction: string;
    let confidence: number;
    
    // Determine which team is more likely to keep a clean sheet
    if (!match.homeOdds || !match.awayOdds || match.homeOdds < match.awayOdds) {
      team = match.homeTeam;
      prediction = "Home Team";
      confidence = match.homeOdds ? Math.round(80 - (match.homeOdds * 10)) : 65;
    } else {
      team = match.awayTeam;
      prediction = "Away Team";
      confidence = match.awayOdds ? Math.round(75 - (match.awayOdds * 10)) : 60;
    }
    
    // Away clean sheets are generally harder to achieve
    if (prediction === "Away Team") {
      confidence = Math.max(confidence - 5, 40);
    }
    
    // Cap confidence for clean sheet predictions
    confidence = Math.min(Math.max(confidence, 40), 75);
    
    return {
      type: PredictionType.CLEAN_SHEET,
      prediction,
      confidence,
      explanation: `Based on defensive strengths and opponent attacking limitations, ${team} has a ${confidence}% chance to keep a clean sheet in this match.`
    };
  }
  
  /**
   * Generate Total Goals prediction (in ranges)
   */
  generateTotalGoalsPrediction(match: StandardizedMatch): PredictionOutcome {
    let prediction: string;
    let confidence: number;
    
    const homeStrength = this.getImpliedProbabilityFromOdds(match.homeOdds);
    const awayStrength = this.getImpliedProbabilityFromOdds(match.awayOdds);
    
    // Calculate total offensive potential
    const offensivePotential = homeStrength + awayStrength;
    
    // Determine goal range based on offensive potential
    if (offensivePotential < 0.7) {
      prediction = "0-1";
      confidence = Math.round((1 - offensivePotential) * 80);
    } else if (offensivePotential < 0.9) {
      prediction = "2-3";
      confidence = Math.round(offensivePotential * 60);
    } else {
      prediction = "4+";
      confidence = Math.round(offensivePotential * 50);
    }
    
    // Adjust confidence for more common ranges
    if (prediction === "2-3") confidence += 5;
    if (prediction === "4+") confidence -= 5;
    
    // Cap confidence for goal range predictions
    confidence = Math.min(Math.max(confidence, 40), 75);
    
    let explanation: string;
    if (prediction === "0-1") {
      explanation = `Expecting a low-scoring affair between ${match.homeTeam} and ${match.awayTeam}. Defensive setups and cautious approaches should limit goal-scoring opportunities.`;
    } else if (prediction === "2-3") {
      explanation = `A typical competitive match between ${match.homeTeam} and ${match.awayTeam} should yield 2-3 goals total, with both teams likely to find scoring opportunities.`;
    } else {
      explanation = `High goal count expected in this match between ${match.homeTeam} and ${match.awayTeam}. Attacking strengths and potential defensive vulnerabilities could lead to a goal fest.`;
    }
    
    return {
      type: PredictionType.TOTAL_GOALS,
      prediction,
      confidence,
      explanation
    };
  }
  
  /**
   * Generate point spread prediction for basketball
   */
  generatePointSpreadPrediction(match: StandardizedMatch): PredictionOutcome {
    const spreadValue = match.homeOdds && match.awayOdds 
      ? match.homeOdds < match.awayOdds ? -5.5 : 5.5
      : -5.5;
    
    const favoredTeam = spreadValue < 0 ? match.homeTeam : match.awayTeam;
    const underdogTeam = spreadValue < 0 ? match.awayTeam : match.homeTeam;
    const absSpread = Math.abs(spreadValue);
    
    const prediction = spreadValue < 0 ? `${match.homeTeam} -${absSpread}` : `${match.awayTeam} -${absSpread}`;
    const confidence = 55 + Math.floor(Math.random() * 20);
    
    return {
      type: PredictionType.MATCH_RESULT, // Reusing match_result type for spread
      prediction,
      confidence,
      explanation: `${favoredTeam} is favored to win by at least ${absSpread} points against ${underdogTeam}. Based on recent form and matchup analysis, we expect them to cover the spread.`
    };
  }
  
  /**
   * Generate accumulator based on selected type and risk level
   */
  generateAccumulator(params: AccumulatorParams): Accumulator {
    const { matches, type, risk, maxSelections, minConfidence } = params;
    
    // Determine number of selections based on risk level
    const numSelections = this.getSelectionsCountByRisk(risk, maxSelections);
    
    // Get minimum confidence threshold based on risk level
    const confidenceThreshold = minConfidence || this.getConfidenceThresholdByRisk(risk);
    
    // Generate selections based on accumulator type
    const selections = this.generateAccumulatorSelections(matches, type, numSelections, confidenceThreshold);
    
    // Calculate total odds (product of all selection odds)
    const totalOdds = selections.reduce((total, sel) => total * sel.odds, 1);
    
    // Calculate average confidence
    const avgConfidence = selections.reduce((sum, sel) => sum + sel.confidence, 0) / selections.length;
    
    // Create accumulator name and description
    const { name, description } = this.getAccumulatorDetails(type, risk, selections.length);
    
    return {
      id: `${type}_${risk}_${new Date().getTime()}`,
      type,
      name,
      description,
      risk,
      selections,
      totalOdds: parseFloat(totalOdds.toFixed(2)),
      potentialReturn: parseFloat((totalOdds).toFixed(2)),
      confidence: Math.round(avgConfidence),
      createdAt: new Date().toISOString(),
      sport: this.determinePrimarySport(selections),
      isFeatured: risk === RiskLevel.BALANCED
    };
  }
  
  /**
   * Generate selections for an accumulator
   */
  private generateAccumulatorSelections(
    matches: StandardizedMatch[],
    type: AccumulatorType,
    count: number,
    minConfidence: number
  ): AccumulatorSelection[] {
    // Filter and sort matches based on accumulator type
    let filteredMatches: StandardizedMatch[] = [...matches];
    
    // Make sure we have matches covering the next 7 days at most
    filteredMatches = filteredMatches.filter(match => {
      const matchDate = new Date(match.startTime);
      const now = new Date();
      const diffTime = matchDate.getTime() - now.getTime();
      const diffDays = diffTime / (1000 * 3600 * 24);
      return diffDays <= 7;
    });
    
    // Sort by start time to prioritize upcoming matches
    filteredMatches.sort((a, b) => {
      return new Date(a.startTime).getTime() - new Date(b.startTime).getTime();
    });
    
    let candidates: { match: StandardizedMatch; prediction: PredictionOutcome }[] = [];
    
    // Generate appropriate predictions based on accumulator type
    switch (type) {
      case AccumulatorType.HOME_WIN_SPECIAL:
        candidates = filteredMatches
          .filter(match => match.homeOdds && match.homeOdds < (match.awayOdds || 99))
          .map(match => ({
            match,
            prediction: {
              type: PredictionType.MATCH_RESULT,
              prediction: "Home Win",
              confidence: Math.round(90 - (match.homeOdds || 2) * 10),
              odds: match.homeOdds || 1.5,
              explanation: `${match.homeTeam} is expected to win at home against ${match.awayTeam}`
            }
          }))
          .filter(candidate => candidate.prediction.confidence >= minConfidence);
        break;
        
      case AccumulatorType.VALUE_FINDER:
        // Generate all possible predictions for all matches
        candidates = filteredMatches.flatMap(match => {
          const predictions = this.generateAllPredictions({ match, includeValue: true });
          return predictions
            .filter(pred => pred.isValueBet)
            .map(prediction => ({ match, prediction }));
        });
        break;
        
      case AccumulatorType.UPSET_SPECIAL:
        candidates = filteredMatches
          .filter(match => {
            // Look for underdogs with reasonable chance
            if (match.awayOdds && match.homeOdds && match.awayOdds > match.homeOdds && match.awayOdds < 4) {
              return true;
            }
            return false;
          })
          .map(match => ({
            match,
            prediction: {
              type: PredictionType.MATCH_RESULT,
              prediction: "Away Win",
              confidence: Math.round(70 - (match.awayOdds || 3) * 5),
              odds: match.awayOdds || 2.5,
              explanation: `Potential upset: ${match.awayTeam} could surprise ${match.homeTeam}`
            }
          }))
          .filter(candidate => candidate.prediction.confidence >= minConfidence - 10); // Lower confidence threshold for upsets
        break;
        
      case AccumulatorType.GOALS_GALORE:
        candidates = filteredMatches
          .filter(match => match.sport.includes('soccer'))
          .map(match => ({
            match,
            prediction: this.generateBTTSPrediction(match)
          }))
          .filter(candidate => 
            candidate.prediction.prediction === "Yes" && 
            candidate.prediction.confidence >= minConfidence
          );
        break;
        
      case AccumulatorType.GOALS_FIESTA:
        candidates = filteredMatches
          .filter(match => match.sport.includes('soccer'))
          .map(match => ({
            match,
            prediction: this.generateOverUnderPrediction(match, 2.5)
          }))
          .filter(candidate => 
            candidate.prediction.prediction === "Over" && 
            candidate.prediction.confidence >= minConfidence
          );
        break;
        
      default:
        // Default to match result predictions sorted by confidence
        candidates = filteredMatches.map(match => ({
          match,
          prediction: this.generateMatchResultPrediction(match)
        }))
        .filter(candidate => candidate.prediction.confidence >= minConfidence);
    }
    
    // Sort candidates by confidence
    candidates.sort((a, b) => b.prediction.confidence - a.prediction.confidence);
    
    // Take top N candidates
    const topCandidates = candidates.slice(0, Math.min(count, candidates.length));
    
    // Convert to AccumulatorSelection format
    return topCandidates.map(candidate => {
      const { match, prediction } = candidate;
      // Ensure startTime is a string
      const startTimeString = typeof match.startTime === 'string' 
        ? match.startTime 
        : match.startTime instanceof Date 
          ? match.startTime.toISOString() 
          : new Date().toISOString();
      
      return {
        matchId: match.id,
        homeTeam: match.homeTeam,
        awayTeam: match.awayTeam,
        league: match.league,
        startTime: startTimeString,
        predictionType: prediction.type,
        selection: prediction.prediction,
        confidence: prediction.confidence,
        odds: prediction.odds || (prediction.prediction === "Home Win" ? match.homeOdds || 1.9 : 
               prediction.prediction === "Away Win" ? match.awayOdds || 2.5 : 
               prediction.prediction === "Draw" ? match.drawOdds || 3.2 : 1.9),
        explanation: prediction.explanation
      };
    });
  }
  
  /**
   * Get number of selections based on risk level
   */
  private getSelectionsCountByRisk(risk: RiskLevel, maxSelections?: number): number {
    const defaultSelections = {
      [RiskLevel.SAFE]: 2,
      [RiskLevel.BALANCED]: 3,
      [RiskLevel.RISKY]: 5
    };
    
    const count = maxSelections || defaultSelections[risk];
    
    // Ensure we have at least 2 selections and at most 6
    return Math.min(Math.max(count, 2), 6);
  }
  
  /**
   * Get confidence threshold based on risk level
   */
  private getConfidenceThresholdByRisk(risk: RiskLevel): number {
    switch (risk) {
      case RiskLevel.SAFE:
        return 75;
      case RiskLevel.BALANCED:
        return 65;
      case RiskLevel.RISKY:
        return 55;
      default:
        return 65;
    }
  }
  
  /**
   * Get accumulator name and description
   */
  private getAccumulatorDetails(type: AccumulatorType, risk: RiskLevel, count: number): { name: string; description: string } {
    const riskName = {
      [RiskLevel.SAFE]: "Safe",
      [RiskLevel.BALANCED]: "Standard",
      [RiskLevel.RISKY]: "Risky"
    };
    
    const typeName = {
      [AccumulatorType.HOME_WIN_SPECIAL]: "Home Win Special",
      [AccumulatorType.VALUE_FINDER]: "Value Finder",
      [AccumulatorType.UPSET_SPECIAL]: "Upset Special",
      [AccumulatorType.GOALS_GALORE]: "Goals Galore",
      [AccumulatorType.GOALS_FIESTA]: "Goals Fiesta"
    };
    
    const typeDescription = {
      [AccumulatorType.HOME_WIN_SPECIAL]: "Strong home teams expected to win their matches",
      [AccumulatorType.VALUE_FINDER]: "Selections offering the best value based on our odds analysis",
      [AccumulatorType.UPSET_SPECIAL]: "Potential upsets with high returns",
      [AccumulatorType.GOALS_GALORE]: "Matches where both teams are expected to score",
      [AccumulatorType.GOALS_FIESTA]: "High-scoring matches with over 2.5 goals expected"
    };
    
    return {
      name: `${count}-Fold ${riskName[risk]} ${typeName[type]}`,
      description: `${riskName[risk]} ${count}-fold accumulator featuring ${typeDescription[type]}.`
    };
  }
  
  /**
   * Calculate value rating based on prediction confidence and odds
   * @returns Value rating on a scale of 1-5
   */
  private calculateValueRating(prediction: PredictionOutcome): number {
    if (!prediction.odds) return 0;
    
    // Calculate implied probability from odds
    const impliedProbability = this.getImpliedProbabilityFromOdds(prediction.odds);
    
    // Calculate our estimated probability from confidence
    const ourProbability = prediction.confidence / 100;
    
    // Calculate value (our probability / implied probability)
    const valueRatio = ourProbability / impliedProbability;
    
    // Convert to 1-5 rating
    if (valueRatio >= 1.3) return 5;
    if (valueRatio >= 1.2) return 4;
    if (valueRatio >= 1.1) return 3;
    if (valueRatio >= 1.0) return 2;
    return 1;
  }
  
  /**
   * Get implied probability from decimal odds
   */
  private getImpliedProbabilityFromOdds(odds?: number): number {
    if (!odds) return 0.5; // Default to 50% if no odds
    return 1 / odds;
  }
  
  /**
   * Get explanation for match result prediction
   */
  private getMatchResultExplanation(prediction: string, confidence: number, match: StandardizedMatch): string {
    if (prediction === "Home Win") {
      return `${match.homeTeam} are favored with a ${confidence}% confidence rating based on their current form and the home advantage factor.`;
    } else if (prediction === "Away Win") {
      return `Despite playing away, ${match.awayTeam} are expected to win with ${confidence}% confidence based on their superior form and matchup advantages.`;
    } else {
      return `A tight contest is expected between these evenly matched teams, with a draw the most likely outcome at ${confidence}% confidence.`;
    }
  }
  
  /**
   * Determine primary sport from selections
   */
  private determinePrimarySport(selections: AccumulatorSelection[]): string {
    // Count occurrences of each sport
    const sportCount: Record<string, number> = {};
    
    selections.forEach(selection => {
      const sport = selection.matchId.split('-')[0];
      sportCount[sport] = (sportCount[sport] || 0) + 1;
    });
    
    // Find most common sport
    let maxCount = 0;
    let primarySport = '';
    
    for (const [sport, count] of Object.entries(sportCount)) {
      if (count > maxCount) {
        maxCount = count;
        primarySport = sport;
      }
    }
    
    // Map internal sport key to display name
    if (primarySport.includes('soccer')) return 'Soccer';
    if (primarySport.includes('basketball')) return 'Basketball';
    if (primarySport.includes('baseball')) return 'Baseball';
    if (primarySport.includes('football')) return 'American Football';
    if (primarySport.includes('hockey')) return 'Hockey';
    
    return 'Mixed';
  }
}

// Export a singleton instance
export const predictionTypesService = new PredictionTypesService();